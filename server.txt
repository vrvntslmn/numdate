// server.js
require("dotenv").config();

const express = require("express");
const path = require("path");
const { MongoClient, ObjectId } = require("mongodb");
const session = require("express-session");
const bcrypt = require("bcryptjs");
const crypto = require("crypto");
const nodemailer = require("nodemailer");
const fs = require("fs");
const multer = require("multer");


// const cors = require("cors"); // ‚úÖ —Ö—ç—Ä–≤—ç—ç frontend ”©”©—Ä –ø–æ—Ä—Ç –¥—ç—ç—Ä –±–∞–π–≤–∞–ª —Ö—ç—Ä—ç–≥—Ç—ç–π

const app = express();
const PORT = process.env.PORT || 3000;

const MONGO_URL = process.env.MONGO_URL;
const DB_NAME = "numdate";
const SESSION_SECRET = process.env.SESSION_SECRET || "change-me-in-prod";

if (!MONGO_URL) throw new Error("Missing MONGO_URL in .env");

// ‚úÖ Body parser (1 —É–¥–∞–∞ –ª!)
app.use(express.json());

const transporter = nodemailer.createTransport({
    host: process.env.SMTP_HOST,
    port: Number(process.env.SMTP_PORT || 587),
    secure: false,
    auth: {
        user: process.env.SMTP_USER,
        pass: process.env.SMTP_PASS,
    },
});

if (!process.env.SMTP_HOST || !process.env.SMTP_USER || !process.env.SMTP_PASS) {
    console.warn("‚ö†Ô∏è SMTP configuration missing ‚Äî email verification will fail.");
}

let db;

/**
* Mongo-backed session store
* sessions: { _id: sid, data: {...session}, updatedAt: Date }
*/
class MongoDBStore extends session.Store {
    constructor(db, collectionName = "sessions") {
        super();
        this.collection = db.collection(collectionName);
    }

    get(sid, callback) {
        this.collection
            .findOne({ _id: sid })
            .then((doc) => callback(null, doc ? doc.data : null))
            .catch((err) => callback(err));
    }

    set(sid, sessionData, callback) {
        this.collection
            .updateOne(
                { _id: sid },
                { $set: { data: sessionData, updatedAt: new Date() } },
                { upsert: true }
            )
            .then(() => callback && callback(null))
            .catch((err) => callback && callback(err));
    }

    destroy(sid, callback) {
        this.collection
            .deleteOne({ _id: sid })
            .then(() => callback && callback(null))
            .catch((err) => callback && callback(err));
    }
}

// -------------------- UPLOADS (Multer) --------------------
const imgUploadDir = path.join(__dirname, "numdate", "img", "uploads");
if (!fs.existsSync(imgUploadDir)) {
    fs.mkdirSync(imgUploadDir, { recursive: true });
}

// SPA static —á–∏–Ω—å –∞–ª—å —Ö—ç–¥–∏–π–Ω:
// app.use(express.static(path.join(__dirname, "numdate")));
// –¢–∏–π–º—ç—ç—Å –Ω—ç–º—ç–ª—Ç static mount —Ö—ç—Ä—ç–≥–≥“Ø–π.
// (–•—ç—Ä–≤—ç—ç —Ö—ç—Ä—ç–≥—Ç—ç–π –±–æ–ª: app.use("/img/uploads", express.static(imgUploadDir));)

const storage = multer.diskStorage({
    destination: (req, file, cb) => cb(null, imgUploadDir),
    filename: (req, file, cb) => {
        const ext = path.extname(file.originalname || "").toLowerCase();
        const safeBase = path
            .basename(file.originalname || "image", ext)
            .replace(/[^a-z0-9_-]/gi, "_")
            .slice(0, 40);

        cb(null, `${safeBase}-${Date.now()}${ext}`);
    },
});

const upload = multer({
    storage,
    limits: { fileSize: 5 * 1024 * 1024 },
    fileFilter: (req, file, cb) => {
        if (!file.mimetype?.startsWith("image/")) {
            return cb(new Error("–ó”©–≤—Ö”©–Ω –∑—É—Ä–∞–≥ upload —Ö–∏–π–Ω—ç."), false);
        }
        cb(null, true);
    },
});


function requireAuth(req, res, next) {
    if (!req.session?.userId) return res.status(401).json({ error: "Not logged in" });
    next();
}

function projectSafeUser(user) {
    if (!user) return null;
    const { passwordHash, ...rest } = user;
    return rest;
}

function calcAge(dob) {
    try {
        const d = new Date(dob);
        if (Number.isNaN(d.getTime())) return null;
        const diff = Date.now() - d.getTime();
        const ageDt = new Date(diff);
        return Math.abs(ageDt.getUTCFullYear() - 1970);
    } catch {
        return null;
    }
}

async function start() {
    const client = new MongoClient(MONGO_URL);
    await client.connect();
    console.log("‚úÖ Connected to MongoDB");
    db = client.db(DB_NAME);

    // ----- Sessions -----
    const store = new MongoDBStore(db, "sessions");

    app.use(
        session({
            name: "sid",
            secret: SESSION_SECRET,
            resave: false,
            saveUninitialized: false,
            store,
            cookie: {
                httpOnly: true,
                secure: process.env.NODE_ENV === "production",
                sameSite: "lax",
                maxAge: 1000 * 60 * 60 * 24 * 7,
            },
        })
    );

    // Static SPA
    app.use(express.static(path.join(__dirname, "numdate")));

    // -------------------- AUTH --------------------

    app.post("/api/auth/register", async (req, res) => {
        try {
            const {
                email,
                password,
                name,
                lname,
                major,
                school,
                dob,
                gender,
                zodiac,
                course,
                mbti,
                loveLanguage,
                relationshipGoal,
                interestedIn,
                interests,
            } = req.body;

            if (!email || !password || !name) {
                return res.status(400).json({ error: "Missing fields" });
            }
            if (!email.endsWith("@stud.num.edu.mn")) {
                return res.status(400).json({ error: "Use your university email (@stud.num.edu.mn)" });
            }

            const existing = await db.collection("users").findOne({ email });
            if (existing) return res.status(409).json({ error: "Email already registered" });

            const passwordHash = await bcrypt.hash(password, 12);

            const verificationToken = crypto.randomBytes(32).toString("hex");
            const verificationExpires = new Date(Date.now() + 1000 * 60 * 60 * 24);

            const userDoc = {
                email,
                passwordHash,
                name,
                major: major || null,
                createdAt: new Date(),
                verified: false,
                verificationToken,
                verificationExpires,
            };

            const result = await db.collection("users").insertOne(userDoc);

            req.session.userId = result.insertedId.toString();

            await new Promise((resolve, reject) =>
                req.session.save(err => (err ? reject(err) : resolve()))
            );

            const age = dob ? calcAge(dob) : null;

            const profileDoc = {
                userId: result.insertedId,
                name: name || null,
                lname: lname || null,
                avatar: null,
                gender: gender || null,
                major: major || null,
                school: school || null,
                year: course || null,
                dob: dob || null,
                age: age,
                about: { zodiac: zodiac || null, mbti: mbti || null },
                relationshipGoal: relationshipGoal || null,
                loveLanguage: loveLanguage || null,
                interests: Array.isArray(interests) ? interests : [],
                interestedIn: interestedIn || null,
                createdAt: new Date(),
                updatedAt: new Date(),
            };

            await db.collection("profile").insertOne(profileDoc);

            const verifyUrl = `${process.env.APP_BASE_URL || "http://localhost:3000"
                }/api/auth/verify-email?token=${verificationToken}&email=${encodeURIComponent(email)}`;

            try {
                await transporter.sendMail({
                    from: `"NumDate" <${process.env.SMTP_USER}>`,
                    to: email,
                    subject: "Verify your NumDate account",
                    text: `–°–∞–π–Ω –±–∞–π–Ω–∞ —É—É, ${name}! –ë–∞—Ç–∞–ª–≥–∞–∞–∂—É—É–ª–∞—Ö –ª–∏–Ω–∫:\n\n${verifyUrl}\n\n24 —Ü–∞–≥ —Ö“Ø—á–∏–Ω—Ç—ç–π.`,
                    html: `
            <p>–°–∞–π–Ω –±–∞–π–Ω–∞ —É—É, ${name} üëã</p>
            <p>–ò–º—ç–π–ª—ç—ç –±–∞—Ç–∞–ª–≥–∞–∞–∂—É—É–ª–∞—Ö—ã–Ω —Ç—É–ª–¥ –¥–æ–æ—Ä—Ö –ª–∏–Ω–∫ –¥—ç—ç—Ä –¥–∞—Ä–Ω–∞ —É—É:</p>
            <p><a href="${verifyUrl}" target="_blank">–ò–º—ç–π–ª –±–∞—Ç–∞–ª–≥–∞–∞–∂—É—É–ª–∞—Ö</a></p>
            <p>–≠–Ω—ç –ª–∏–Ω–∫ 24 —Ü–∞–≥ —Ö“Ø—á–∏–Ω—Ç—ç–π.</p>
          `,
                });
            } catch (mailErr) {
                console.error("Email send error:", mailErr);
            }

            res.status(201).json({ ok: true, message: "Registered. Please verify your email." });
        } catch (err) {
            console.error("Register error", err);
            res.status(500).json({ error: "Server error" });
        }
    });

    app.get("/api/auth/verify-email", async (req, res) => {
        try {
            const { token, email } = req.query;
            if (!token || !email) return res.status(400).send("Invalid verification link");

            const user = await db.collection("users").findOne({ email });
            if (!user) return res.status(400).send("Invalid verification link");

            if (user.verified) return res.redirect("/?alreadyVerified=1");

            if (
                user.verificationToken !== token ||
                !user.verificationExpires ||
                user.verificationExpires < new Date()
            ) {
                return res.status(400).send("Verification link is invalid or expired");
            }

            await db.collection("users").updateOne(
                { _id: user._id },
                { $set: { verified: true }, $unset: { verificationToken: "", verificationExpires: "" } }
            );

            req.session.userId = user._id.toString();
            return res.redirect("/?verified=1");
        } catch (err) {
            console.error("Verify email error", err);
            res.status(500).send("Server error");
        }
    });

    app.post("/api/auth/login", async (req, res) => {
        try {
            const { email, password } = req.body;
            if (!email || !password) return res.status(400).json({ error: "Missing email or password" });

            const user = await db.collection("users").findOne({ email });
            if (!user) return res.status(401).json({ error: "Invalid credentials" });

            const match = await bcrypt.compare(password, user.passwordHash);
            if (!match) return res.status(401).json({ error: "Invalid credentials" });

            if (!user.verified) {
                return res.status(403).json({ error: "Email not verified" });
            }

            req.session.userId = user._id.toString();
            res.json({ ok: true, user: projectSafeUser(user) });
        } catch (err) {
            console.error("Login error", err);
            res.status(500).json({ error: "Server error" });
        }
    });

    app.post("/api/auth/logout", (req, res) => {
        req.session.destroy((err) => {
            if (err) console.error("Session destroy error", err);
            res.clearCookie("sid");
            res.json({ ok: true });
        });
    });

    app.get("/api/me", async (req, res) => {
        try {
            if (!req.session.userId) return res.status(401).json({ user: null });
            const user = await db.collection("users").findOne({ _id: new ObjectId(req.session.userId) });
            if (!user) return res.status(401).json({ user: null });
            res.json({ user: projectSafeUser(user) });
        } catch (err) {
            console.error("Me error", err);
            res.status(500).json({ error: "Server error" });
        }
    });

    app.post("/api/auth/resend-verification", async (req, res) => {
        try {
            const { email } = req.body;
            if (!email) return res.status(400).json({ error: "Email required" });

            const user = await db.collection("users").findOne({ email });
            if (!user) return res.status(400).json({ error: "No such user" });
            if (user.verified) return res.status(400).json({ error: "Already verified" });

            const verificationToken = crypto.randomBytes(32).toString("hex");
            const verificationExpires = new Date(Date.now() + 1000 * 60 * 60 * 24);

            await db.collection("users").updateOne(
                { _id: user._id },
                { $set: { verificationToken, verificationExpires } }
            );

            const verifyUrl = `${process.env.APP_BASE_URL || "http://localhost:3000"
                }/api/auth/verify-email?token=${verificationToken}&email=${encodeURIComponent(email)}`;

            await transporter.sendMail({
                from: `"NumDate" <${process.env.SMTP_USER}>`,
                to: email,
                subject: "New verification link",
                text: `Here is your new verification link: ${verifyUrl}`,
            });

            res.json({ ok: true, message: "Verification email sent" });
        } catch (err) {
            console.error("Resend verification error", err);
            res.status(500).json({ error: "Server error" });
        }
    });

    // -------------------- PROFILE --------------------

    app.get("/api/profile", requireAuth, async (req, res) => {
        try {
            const userId = new ObjectId(req.session.userId);
            const profile = await db.collection("profile").findOne({ userId }, { projection: { _id: 0 } });
            if (!profile) return res.status(404).json({ error: "Profile not found" });

            res.json({ ...profile, userId: profile.userId.toString() });
        } catch (err) {
            console.error("Profile error", err);
            res.status(500).json({ error: "Server error" });
        }
    });

    app.get("/api/profile/:userId", requireAuth, async (req, res) => {
        try {
            const otherId = new ObjectId(req.params.userId);
            const profile = await db.collection("profile").findOne(
                { userId: otherId },
                { projection: { _id: 0 } }
            );
            if (!profile) return res.status(404).json({ error: "Profile not found" });

            res.json({ ...profile, userId: profile.userId.toString() });
        } catch (e) {
            console.error(e);
            res.status(400).json({ error: "Invalid userId" });
        }
    });

    // -------------------- PROFILES LIST --------------------
    app.get("/api/profiles", async (req, res) => {
        try {
            const profiles = await db
                .collection("profile")
                .find({})
                .project({
                    _id: 0,
                    userId: 1,
                    name: 1,
                    age: 1,
                    avatar: 1,
                    major: 1,
                    school: 1,
                    year: 1,
                    bio: 1,
                    about: 1,
                    relationshipGoal: 1,
                    loveLanguage: 1,
                    interests: 1,
                })
                .toArray();

            const formatted = profiles.map((p) => ({
                ...p,
                userId: p.userId?.toString?.() || p.userId,
                image: p.avatar || "img/default-profile.jpg",
            }));

            res.json(formatted);
        } catch (e) {
            console.error(e);
            res.status(500).json({ error: "Database error" });
        }
    });

    // -------------------- SWIPES --------------------
    app.post("/api/swipes", requireAuth, async (req, res) => {
        try {
            const { action, targetUserId, targetName, at } = req.body;

            if (!action || !["like", "pass"].includes(action)) {
                return res.status(400).json({ error: "Invalid action" });
            }
            if (!targetUserId) {
                return res.status(400).json({ error: "Missing targetUserId" });
            }

            const fromUserIdObj = new ObjectId(req.session.userId);
            const targetStr = String(targetUserId);

            const doc = {
                fromUserId: fromUserIdObj,
                action,
                targetName: targetName || null,
                at: at ? new Date(at) : new Date(),
                targetUserIdObj: ObjectId.isValid(targetStr) ? new ObjectId(targetStr) : null,
                targetUserIdStr: ObjectId.isValid(targetStr) ? null : targetStr,
            };

            await db.collection("swipes").insertOne(doc);

            res.json({ ok: true });
        } catch (err) {
            console.error("POST /api/swipes error:", err);
            res.status(500).json({ error: "Server error" });
        }
    });

    app.get("/api/swipes/me", requireAuth, async (req, res) => {
        try {
            const me = new ObjectId(req.session.userId);

            const docs = await db
                .collection("swipes")
                .find({ fromUserId: me })
                .project({ _id: 0, action: 1, targetUserIdObj: 1, targetUserIdStr: 1, at: 1 })
                .sort({ at: -1 })
                .limit(200)
                .toArray();

            res.json({
                items: docs.map((d) => ({
                    action: d.action,
                    targetUserId: d.targetUserIdObj?.toString?.() || d.targetUserIdStr || null,
                    at: d.at,
                })),
            });
        } catch (e) {
            console.error("GET /api/swipes/me failed:", e);
            res.status(500).json({ items: [] });
        }
    });

    // -------------------- LIKES --------------------

    app.get("/api/likes/me", requireAuth, async (req, res) => {
        try {
            const me = new ObjectId(req.session.userId);

            const docs = await db
                .collection("likes")
                .find({ fromUserId: me })
                .project({ _id: 0, toUserId: 1 })
                .toArray();

            res.json({ ids: docs.map((d) => d.toUserId.toString()) });
        } catch (e) {
            console.error("GET /api/likes/me failed:", e);
            res.status(500).json({ ids: [] });
        }
    });

    // ‚úÖ Like —Ö–∏–π—Ö
    app.post("/api/like", requireAuth, async (req, res) => {
        try {
            const meStr = String(req.session.userId || "");
            const toStr = String(req.body?.toUserId || "");

            if (!ObjectId.isValid(meStr)) return res.status(401).json({ ok: false, error: "not_logged_in" });
            if (!ObjectId.isValid(toStr)) return res.status(400).json({ ok: false, error: "bad_toUserId" });

            const me = new ObjectId(meStr);
            const other = new ObjectId(toStr);

            // ‚úÖ 1) like upsert
            await db.collection("likes").updateOne(
                { fromUserId: me, toUserId: other },
                { $setOnInsert: { fromUserId: me, toUserId: other, createdAt: new Date() } },
                { upsert: true }
            );

            // ‚úÖ 2) mutual like —à–∞–ª–≥–∞—Ö (other -> me)
            const reverse = await db.collection("likes").findOne({ fromUserId: other, toUserId: me });

            if (!reverse) {
                return res.json({ ok: true, matched: false });
            }

            // ‚úÖ 3) match “Ø“Ø—Å–≥—ç—Ö
            const users = [me, other].sort((a, b) => a.toString().localeCompare(b.toString()));

            await db.collection("matches").updateOne(
                { users },
                { $setOnInsert: { users, createdAt: new Date() } },
                { upsert: true }
            );

            const matchDoc = await db.collection("matches").findOne({ users }, { projection: { _id: 1 } });
            const matchId = matchDoc._id;

            // ‚úÖ 4) notifications 2 —Ç–∞–ª–¥ –Ω—å (seen:false)
            await db.collection("notifications").updateOne(
                { userId: me, type: "match", matchId },
                {
                    $setOnInsert: {
                        userId: me,
                        type: "match",
                        matchId,
                        otherUserId: other,
                        createdAt: new Date(),
                        seen: false,     // ‚úÖ badge-–¥ –∑–æ—Ä–∏—É–ª–∂
                        seenAt: null,
                        read: false      // (optional) list-–¥ —Ö—ç—Ä—ç–≥—Ç—ç–π –±–∞–π–∂ –±–æ–ª–Ω–æ
                    }
                },
                { upsert: true }
            );

            await db.collection("notifications").updateOne(
                { userId: other, type: "match", matchId },
                {
                    $setOnInsert: {
                        userId: other,
                        type: "match",
                        matchId,
                        otherUserId: me,
                        createdAt: new Date(),
                        seen: false,
                        seenAt: null,
                        read: false
                    }
                },
                { upsert: true }
            );

            return res.json({ ok: true, matched: true, matchId: matchId.toString() });
        } catch (e) {
            console.error("POST /api/like failed:", e);
            return res.status(500).json({ ok: false, error: "server_error" });
        }
    });

    // -------------------- OTHER ROUTES (yours, unchanged) --------------------
    app.get("/api/dateideas", async (req, res) => {
        try {
            const [cats, topCards, catCards] = await Promise.all([
                db.collection("date_categories").find({}).sort({ order: 1 }).toArray(),
                db.collection("date_cards").find({ isTop: true }).sort({ order: 1 }).toArray(),
                db.collection("date_cards").find({ isTop: false }).sort({ categoryId: 1, order: 1 }).toArray(),
            ]);

            const topPicks = topCards.map((c) => ({
                id: c._id,
                title: c.title,
                displayTitle: c.displayTitle || c.title,
                subtitle: c.subtitle || "",
                detail: c.detail || "",
                image: c.image || "",
                meta: c.meta || "",
                tags: Array.isArray(c.tags) ? c.tags : [],
            }));

            const categories = cats.map((cat) => {
                const cards = catCards
                    .filter((c) => String(c.categoryId) === String(cat._id))
                    .sort((a, b) => (a.order ?? 999) - (b.order ?? 999))
                    .map((c) => ({
                        id: c._id,
                        title: c.title,
                        displayTitle: c.displayTitle || c.title,
                        detail: c.detail || "",
                        image: c.image || "",
                        meta: c.meta || "",
                        tags: Array.isArray(c.tags) ? c.tags : [],
                    }));

                return { id: cat._id, name: cat.name, desc: cat.desc || "", cards };
            });

            res.json({ topPicks, categories });
        } catch (e) {
            console.error(e);
            res.status(500).json({ error: "Failed to load date ideas" });
        }
    });

    app.get("/api/recipients", async (req, res) => {
        try {
            const docs = await db.collection("recipients").find({}).sort({ order: 1 }).toArray();
            res.json(docs.map((r) => ({ id: r.id, name: r.name, avatar: r.avatar })));
        } catch (e) {
            console.error(e);
            res.status(500).json({ error: "Failed to load recipients" });
        }
    });

    // ‚úÖ Notification list (seen/read-–≥ –∑“Ø–≥—ç—ç—Ä –±—É—Ü–∞–∞–Ω–∞)
    app.get("/api/notifications", requireAuth, async (req, res) => {
        try {
            const me = new ObjectId(req.session.userId);

            const notifs = await db.collection("notifications")
                .find({ userId: me })
                .sort({ createdAt: -1 })
                .limit(50)
                .toArray();

            const otherIds = notifs
                .filter(n => n.type === "match")
                .map(n => n.otherUserId)
                .filter(Boolean);

            const others = await db.collection("profile")
                .find({ userId: { $in: otherIds } })
                .project({ _id: 0, userId: 1, name: 1, avatar: 1, major: 1, gender: 1 })
                .toArray();

            const byId = new Map(others.map(p => [p.userId.toString(), p]));

            const items = notifs.map(n => {
                const other = byId.get(n.otherUserId?.toString?.() || "");
                return {
                    id: n._id.toString(),
                    type: n.type,
                    createdAt: n.createdAt,
                    read: !!n.read,
                    seen: !!n.seen,
                    matchId: n.matchId?.toString?.() || null,
                    other: {
                        userId: n.otherUserId?.toString?.() || null,
                        name: other?.name || "Unknown",
                        avatar: other?.avatar || "",
                        major: other?.major || "",
                        gender: other?.gender || "",
                    }
                };
            });

            res.json({ items });
        } catch (e) {
            console.error("GET /api/notifications failed:", e);
            res.status(500).json({ items: [] });
        }
    });

    // ‚úÖ badge-–¥: –Ω–∏–π—Ç unread (read:false) —Ç–æ–æ
    app.get("/api/notifications/unread-count", requireAuth, async (req, res) => {
        try {
            const me = new ObjectId(req.session.userId);

            const count = await db.collection("notifications").countDocuments({
                userId: me,
                read: false,
            });

            res.json({ count });
        } catch (e) {
            console.error("GET /api/notifications/unread-count failed:", e);
            res.status(500).json({ count: 0 });
        }
    });

    // ‚úÖ list –¥—ç—ç—Ä "—É–Ω—à—Å–∞–Ω" –±–æ–ª–≥–æ—Ö (read:true)
    app.post("/api/notifications/mark-read", requireAuth, async (req, res) => {
        try {
            const me = new ObjectId(req.session.userId);
            await db.collection("notifications").updateMany(
                { userId: me, read: false },
                { $set: { read: true } }
            );
            res.json({ ok: true });
        } catch (e) {
            console.error("mark-read failed", e);
            res.status(500).json({ ok: false });
        }
    });
    app.get('/api/notifications/matches', requireAuth, async (req, res) => {
        try {
            const me = new ObjectId(req.session.userId);

            const items = await db.collection('notifications')
                .find({ userId: me, type: 'match', read: false })  // ‚úÖ read –∞—à–∏–≥–ª–∞—è
                .sort({ createdAt: -1 })
                .limit(50)
                .toArray();

            res.json({ items });
        } catch (e) {
            res.status(500).json({ items: [] });
        }
    });

    app.post('/api/notifications/matches/seen', requireAuth, async (req, res) => {
        try {
            const me = new ObjectId(req.session.userId);

            await db.collection('notifications').updateMany(
                { userId: me, type: 'match', read: false },
                { $set: { read: true, readAt: new Date() } }
            );

            res.json({ ok: true });
        } catch (e) {
            res.status(500).json({ ok: false });
        }
    });
    // -------------------- MESSAGES --------------------
    app.post("/api/messages", requireAuth, async (req, res) => {
        try {
            const me = new ObjectId(req.session.userId);
            const { other, text, type } = req.body;

            if (!ObjectId.isValid(other)) return res.status(400).json({ error: "bad_other" });
            if (!text || !String(text).trim()) return res.status(400).json({ error: "empty_text" });

            const otherId = new ObjectId(other);

            const doc = {
                fromUserId: me,
                toUserId: otherId,
                text: String(text),
                type: type || "text",
                createdAt: new Date(),
            };

            await db.collection("messages").insertOne(doc);
            res.json({ ok: true });
        } catch (e) {
            console.error("POST /api/messages failed:", e);
            res.status(500).json({ error: "server_error" });
        }
    });

    app.get("/api/messages", requireAuth, async (req, res) => {
        try {
            const me = new ObjectId(req.session.userId);
            const other = String(req.query.other || "");
            const limit = Math.min(Number(req.query.limit || 200), 500);

            if (!ObjectId.isValid(other)) return res.status(400).json({ error: "bad_other" });
            const otherId = new ObjectId(other);

            const msgs = await db.collection("messages")
                .find({
                    $or: [
                        { fromUserId: me, toUserId: otherId },
                        { fromUserId: otherId, toUserId: me },
                    ]
                })
                .sort({ createdAt: 1 })
                .limit(limit)
                .toArray();

            res.json(msgs);
        } catch (e) {
            console.error("GET /api/messages failed:", e);
            res.status(500).json({ error: "server_error" });
        }
    });

    app.get("/api/matches", requireAuth, async (req, res) => {
        try {
            const me = new ObjectId(req.session.userId);

            // 1) me –æ—Ä—Å–æ–Ω match-—É—É–¥ (users: [ObjectId, ObjectId])
            const matches = await db.collection("matches")
                .find({ users: me })
                .sort({ createdAt: -1 })
                .toArray();

            // 2) match –±“Ø—Ä—ç—ç—Å "–Ω”©–≥”©”© —Ö“Ø–Ω–∏–π" ObjectId-–≥ –≥–∞—Ä–≥–∞—Ö
            const otherIds = matches
                .map(m => (m.users || []).find(u => String(u) !== String(me)))
                .filter(Boolean);

            if (!otherIds.length) return res.json([]);

            // 3) profile collection-–æ–æ—Å userId-–æ–æ—Ä –Ω—å –∞–≤–∞—Ö (userId: ObjectId)
            const people = await db.collection("profile")
                .find({ userId: { $in: otherIds } })
                .project({
                    _id: 0,
                    userId: 1,
                    name: 1,
                    lname: 1,
                    avatar: 1,
                    gender: 1,
                    major: 1,
                    school: 1,
                    year: 1,
                    dob: 1,
                    about: 1,
                    relationshipGoal: 1,
                    loveLanguage: 1,
                    interests: 1,
                    interestedIn: 1,
                })
                .toArray();

            // 4) match-–∏–π–Ω –¥–∞—Ä–∞–∞–ª–ª–∞–∞—Ä —ç—Ä—ç–º–±—ç–ª–∂ –±—É—Ü–∞–∞—Ö
            const map = new Map(people.map(p => [String(p.userId), p]));
            const ordered = otherIds.map(id => map.get(String(id))).filter(Boolean);

            res.json(ordered);
        } catch (e) {
            console.error("GET /api/matches failed:", e);
            res.status(500).json({ error: "Server error" });
        }
    });
    app.post("/api/upload/image", requireAuth, upload.single("image"), async (req, res) => {
        try {
            if (!req.file) return res.status(400).json({ error: "–§–∞–π–ª –∏—Ä—Å—ç–Ω–≥“Ø–π." });

            const { type, index } = req.body;
            const url = `/img/uploads/${req.file.filename}`; // ‚úÖ —ç–Ω–¥

            const userId = new ObjectId(req.session.userId);

            if (type === "avatar") {
                await db.collection("profile").updateOne(
                    { userId },
                    { $set: { avatar: url, updatedAt: new Date() } }
                );
            } else if (type === "gallery") {
                const idx = Number(index);
                if (!Number.isInteger(idx) || idx < 0 || idx > 3) {
                    return res.status(400).json({ error: "index –±—É—Ä—É—É (0-3)" });
                }

                await db.collection("profile").updateOne(
                    { userId },
                    { $set: { [`photos.${idx}`]: url, updatedAt: new Date() } }
                );
            }

            return res.json({ url });
        } catch (err) {
            console.error("Upload error:", err);
            return res.status(500).json({ error: "Upload –¥–æ—Ç–æ—Ä –∞–ª–¥–∞–∞ –≥–∞—Ä–ª–∞–∞." });
        }
    });


    // -------------------- START --------------------
    app.listen(PORT, () => {
        console.log(`üöÄ Server running on http://localhost:${PORT}`);
    });
} // <-- start() —Ö–∞–∞–≥–¥–∞–Ω–∞

start().catch((err) => {
    console.error("Startup error", err);
    process.exit(1);
});
